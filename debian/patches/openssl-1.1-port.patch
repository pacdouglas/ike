--- ike.orig/source/libike/manager.file.cpp
+++ ike/source/libike/manager.file.cpp
@@ -679,11 +679,11 @@ bool _CONFIG_MANAGER::file_pcf_load( CON
 			BDATA pwd;
 			data.get( pwd );
 
-			EVP_CIPHER_CTX ctx_cipher;
-			EVP_CIPHER_CTX_init( &ctx_cipher );
+			EVP_CIPHER_CTX * ctx_cipher = EVP_CIPHER_CTX_new();
+			EVP_CIPHER_CTX_init( ctx_cipher );
 
 			EVP_CipherInit_ex(
-				&ctx_cipher,
+				ctx_cipher,
 				EVP_des_ede3_cbc(),
 				NULL,
 				key,
@@ -691,11 +691,13 @@ bool _CONFIG_MANAGER::file_pcf_load( CON
 				0 );
 
 			EVP_Cipher(
-				&ctx_cipher,
+				ctx_cipher,
 				pwd.buff(),
 				pwd.buff(),
 				( unsigned int ) pwd.size() );
 
+			EVP_CIPHER_CTX_free( ctx_cipher );
+
 			pwlen -= pwd.buff()[ pwd.size() - 1 ];
 			pwd.size( pwlen );
 
--- ike.orig/source/iked/crypto.cpp
+++ ike/source/iked/crypto.cpp
@@ -39,6 +39,8 @@
  *
  */
 
+#include <memory>
+
 #include "crypto.h"
 
 void crypto_init()
@@ -372,97 +374,92 @@ static unsigned char group18[] =
 
 bool dh_init( long group, DH ** dh_data, long * dh_size )
 {
-	DH * dh = DH_new();
-	if( dh == NULL )
+	std::unique_ptr<DH, decltype(&DH_free)> dh {DH_new(), DH_free};
+	if( !dh )
 		return false;
 
-	dh->p = NULL;
-	dh->g = NULL;
-	dh->length = 0;
-
 	//
 	// set p ( prime ) value
 	//
 
-	unsigned char * p_data = NULL;
-	size_t			p_size = 0;
-
-	dh->p = BN_new();
-	if( dh->p == NULL )
-		goto dh_failed;
+	std::unique_ptr<BIGNUM, decltype(&BN_clear_free)> dh_p {BN_new(), BN_clear_free};
+	if( !dh_p )
+		return false;
 
 	switch( group )
 	{
 		case 1:
-			if( !BN_bin2bn( group1, sizeof( group1 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group1, sizeof( group1 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 2:
-			if( !BN_bin2bn( group2, sizeof( group2 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group2, sizeof( group2 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 5:
-			if( !BN_bin2bn( group5, sizeof( group5 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group5, sizeof( group5 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 14:
-			if( !BN_bin2bn( group14, sizeof( group14 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group14, sizeof( group14 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 15:
-			if( !BN_bin2bn( group15, sizeof( group15 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group15, sizeof( group15 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 16:
-			if( !BN_bin2bn( group16, sizeof( group16 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group16, sizeof( group16 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 17:
-			if( !BN_bin2bn( group17, sizeof( group17 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group17, sizeof( group17 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 18:
-			if( !BN_bin2bn( group18, sizeof( group18 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group18, sizeof( group18 ), dh_p.get() ) )
+				return false;
 			break;
 
 		default:
-			goto dh_failed;
+			return false;
 	}
 
 	//
 	// set g ( generator ) value
 	//
 
-	dh->g = BN_new();
-	if( dh->g == NULL )
-		goto dh_failed;
+	std::unique_ptr<BIGNUM, decltype(&BN_clear_free)> dh_g {BN_new(), BN_clear_free};
+	if( !dh_g )
+		return false;
+
+	if( !BN_set_word( dh_g.get(), 2 ) )
+		return false;
 
-	if( !BN_set_word( dh->g, 2 ) )
-		goto dh_failed;
+	if( DH_set0_pqg (dh.get(), dh_p.get(), dh_g.get(), nullptr) ) {
+		dh_p.release();
+		dh_g.release();
+	}
 
 	//
 	// generate private and public DH values
 	//
 
-	if( !DH_generate_key( dh ) )
-		goto dh_failed;
-
-	*dh_data = dh;
-	*dh_size = BN_num_bytes( dh->p );
+	if( !DH_generate_key( dh.get() ) )
+		return false;
 
+	{
+		const BIGNUM * p;
+		DH_get0_pqg ( dh.get(), &p, nullptr, nullptr );
+		*dh_size = BN_num_bytes( p );
+	}
+	*dh_data = dh.release();
 	return true;
-
-	dh_failed:
-
-	DH_free( dh );
-
-	return false;
 }
--- ike.orig/source/iked/ike.exch.config.cpp
+++ ike/source/iked/ike.exch.config.cpp
@@ -2481,15 +2481,14 @@ long _IKED::config_chk_hash( IDB_PH1 * p
 	BDATA hash_c;
 	hash_c.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &msgid, 4 );
-	HMAC_Update( &ctx_prf, cfg->hda.buff(), cfg->hda.size() );
-	HMAC_Final( &ctx_prf, hash_c.buff(), NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &msgid, 4 );
+	HMAC_Update( ctx_prf, cfg->hda.buff(), cfg->hda.size() );
+	HMAC_Final( ctx_prf, hash_c.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -2543,15 +2542,14 @@ long _IKED::config_message_send( IDB_PH1
 	// create message authentication hash
 	//
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &cfg->msgid, sizeof( cfg->msgid ) );
-	HMAC_Update( &ctx_prf, packet.buff() + beg, end - beg );
-	HMAC_Final( &ctx_prf, hash.buff(), 0 );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &cfg->msgid, sizeof( cfg->msgid ) );
+	HMAC_Update( ctx_prf, packet.buff() + beg, end - beg );
+	HMAC_Final( ctx_prf, hash.buff(), 0 );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	memcpy( packet.buff() + off + 4, hash.buff(), hash.size() );
 
--- ike.orig/source/iked/ike.cpp
+++ ike/source/iked/ike.cpp
@@ -391,11 +391,10 @@ long _IKED::packet_ike_decrypt( IDB_PH1
 	// init cipher key and iv
 	//
 
-	EVP_CIPHER_CTX ctx_cipher;
-	EVP_CIPHER_CTX_init( &ctx_cipher );
+	EVP_CIPHER_CTX * ctx_cipher = EVP_CIPHER_CTX_new();
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		sa->evp_cipher,
 		NULL,
 		NULL,
@@ -403,11 +402,11 @@ long _IKED::packet_ike_decrypt( IDB_PH1
 		0 );
 
 	EVP_CIPHER_CTX_set_key_length(
-		&ctx_cipher,
+		ctx_cipher,
 		( int ) sa->key.size() );
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		NULL,
 		NULL,
 		sa->key.buff(),
@@ -419,12 +418,12 @@ long _IKED::packet_ike_decrypt( IDB_PH1
 	//
 
 	EVP_Cipher(
-		&ctx_cipher,
+		ctx_cipher,
 		data + sizeof( IKE_HEADER ),
 		data + sizeof( IKE_HEADER ),
 		( int ) size - sizeof( IKE_HEADER ) );
 
-	EVP_CIPHER_CTX_cleanup( &ctx_cipher );
+	EVP_CIPHER_CTX_free( ctx_cipher );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -595,11 +594,10 @@ long _IKED::packet_ike_encrypt( IDB_PH1
 	// encrypt all but header
 	//
 
-	EVP_CIPHER_CTX ctx_cipher;
-	EVP_CIPHER_CTX_init( &ctx_cipher );
+	EVP_CIPHER_CTX * ctx_cipher = EVP_CIPHER_CTX_new();
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		sa->evp_cipher,
 		NULL,
 		NULL,
@@ -607,11 +605,11 @@ long _IKED::packet_ike_encrypt( IDB_PH1
 		1 );
 
 	EVP_CIPHER_CTX_set_key_length(
-		&ctx_cipher,
+		ctx_cipher,
 		( int ) sa->key.size() );
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		NULL,
 		NULL,
 		sa->key.buff(),
@@ -619,12 +617,12 @@ long _IKED::packet_ike_encrypt( IDB_PH1
 		1 );
 
 	EVP_Cipher(
-		&ctx_cipher,
+		ctx_cipher,
 		data + sizeof( IKE_HEADER ),
 		data + sizeof( IKE_HEADER ),
 		( int ) size - sizeof( IKE_HEADER ) );
 
-	EVP_CIPHER_CTX_cleanup( &ctx_cipher );
+	EVP_CIPHER_CTX_cleanup( ctx_cipher );
 
 	//
 	// store cipher iv data
--- ike.orig/source/iked/ike.exch.inform.cpp
+++ ike/source/iked/ike.exch.inform.cpp
@@ -399,15 +399,14 @@ long _IKED::inform_chk_hash( IDB_PH1 * p
 	BDATA hash_c;
 	hash_c.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &inform->msgid, 4 );
-	HMAC_Update( &ctx_prf, inform->hda.buff(), inform->hda.size() );
-	HMAC_Final( &ctx_prf, hash_c.buff(), NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &inform->msgid, 4 );
+	HMAC_Update( ctx_prf, inform->hda.buff(), inform->hda.size() );
+	HMAC_Final( ctx_prf, hash_c.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -439,15 +438,14 @@ long _IKED::inform_gen_hash( IDB_PH1 * p
 {
 	inform->hash_l.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &inform->msgid, sizeof( inform->msgid ) );
-	HMAC_Update( &ctx_prf, inform->hda.buff(), inform->hda.size() );
-	HMAC_Final( &ctx_prf, inform->hash_l.buff(), 0 );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &inform->msgid, sizeof( inform->msgid ) );
+	HMAC_Update( ctx_prf, inform->hda.buff(), inform->hda.size() );
+	HMAC_Final( ctx_prf, inform->hash_l.buff(), 0 );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
--- ike.orig/source/iked/ike.exch.phase2.cpp
+++ ike/source/iked/ike.exch.phase2.cpp
@@ -1008,14 +1008,13 @@ long _IKED::phase2_gen_hash_i( IDB_PH1 *
 
 	hash.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, input.buff(), input.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, input.buff(), input.size() );
+	HMAC_Final( ctx_prf, hash.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1048,14 +1047,13 @@ long _IKED::phase2_gen_hash_r( IDB_PH1 *
 
 	hash.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, input.buff(), input.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, input.buff(), input.size() );
+	HMAC_Final( ctx_prf, hash.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1093,14 +1091,13 @@ long _IKED::phase2_gen_hash_p( IDB_PH1 *
 
 	hash.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, input.buff(), input.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), 0 );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, input.buff(), input.size() );
+	HMAC_Final( ctx_prf, hash.buff(), 0 );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1555,7 +1552,9 @@ long _IKED::phase2_gen_keys( IDB_PH1 * p
 		{
 			BDATA prv;
 			prv.size( ph2->dh_size );
-			BN_bn2bin( ph2->dh->priv_key, prv.buff() );
+			const BIGNUM * priv_key;
+			DH_get0_key (ph2->dh, nullptr, &priv_key);
+			BN_bn2bin( priv_key, prv.buff() );
 
 			log.bin(
 				LLOG_DECODE,
@@ -1817,56 +1816,55 @@ long _IKED::phase2_gen_keys( IDB_PH1 * p
 	// K3 = prf( SKEYID_d, K2 | [ g(qm)^xy | ] protocol | SPI | Ni_b | Nr_b )
 	//
 	
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
 
 	if( ph2->dhgr_id )
-		HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
+		HMAC_Update( ctx_prf, shared.buff(), shared.size() );
 
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
 
 	if( ph2->initiator )
 	{
-		HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
-		HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+		HMAC_Update( ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+		HMAC_Update( ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
 	}
 	else
 	{
-		HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
-		HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+		HMAC_Update( ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+		HMAC_Update( ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
 	}
 
-	HMAC_Final( &ctx_prf, key_data, NULL );
+	HMAC_Final( ctx_prf, key_data, NULL );
 
 	for( long size = skeyid_size; size < key_size; size += skeyid_size )
 	{
-		HMAC_Init_ex( &ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
-		HMAC_Update( &ctx_prf, key_data + size - skeyid_size, skeyid_size );
+		HMAC_Init_ex( ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
+		HMAC_Update( ctx_prf, key_data + size - skeyid_size, skeyid_size );
 
 		if( ph2->dhgr_id )
-			HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
+			HMAC_Update( ctx_prf, shared.buff(), shared.size() );
 
-		HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
-		HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
+		HMAC_Update( ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
+		HMAC_Update( ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
 
 		if( ph2->initiator )
 		{
-			HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
-			HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+			HMAC_Update( ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+			HMAC_Update( ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
 		}
 		else
 		{
-			HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
-			HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+			HMAC_Update( ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+			HMAC_Update( ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
 		}
 
-		HMAC_Final( &ctx_prf, key_data + size, 0 );
+		HMAC_Final( ctx_prf, key_data + size, 0 );
 	}
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	//
 	// separate encrypt and auth key data
--- ike.orig/source/iked/ike.exch.phase1.cpp
+++ ike/source/iked/ike.exch.phase1.cpp
@@ -1044,14 +1044,13 @@ long _IKED::process_phase1_send( IDB_PH1
 								BDATA psk_hash;
 								psk_hash.size( ph1->hash_size );
 
-								HMAC_CTX ctx_prf;
-								HMAC_CTX_init( &ctx_prf );
+								HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-								HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-								HMAC_Update( &ctx_prf, ph1->tunnel->peer->psk.buff(), ph1->tunnel->peer->psk.size() );
-								HMAC_Final( &ctx_prf, psk_hash.buff(), NULL );
+								HMAC_Init_ex( ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+								HMAC_Update( ctx_prf, ph1->tunnel->peer->psk.buff(), ph1->tunnel->peer->psk.size() );
+								HMAC_Final( ctx_prf, psk_hash.buff(), NULL );
 
-								HMAC_CTX_cleanup( &ctx_prf );
+								HMAC_CTX_free( ctx_prf );
 
 								//
 								// add the notification payload
@@ -1557,7 +1556,9 @@ long _IKED::phase1_gen_keys( IDB_PH1 * p
 	{
 		BDATA prv;
 		prv.size( ph1->dh_size );
-		BN_bn2bin( ph1->dh->priv_key, prv.buff() );
+		const BIGNUM * priv_key;
+		DH_get0_key (ph1->dh, nullptr, &priv_key);
+		BN_bn2bin( priv_key, prv.buff() );
 
 		log.bin(
 			LLOG_DECODE,
@@ -1656,25 +1657,24 @@ long _IKED::phase1_gen_keys( IDB_PH1 * p
 		case XAUTH_AUTH_INIT_PSK:
 		case XAUTH_AUTH_RESP_PSK:
 		{
-			HMAC_CTX ctx_prf;
-			HMAC_CTX_init( &ctx_prf );
+			HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-			HMAC_Init_ex( &ctx_prf, ph1->tunnel->peer->psk.buff(), ( int ) ph1->tunnel->peer->psk.size(), ph1->evp_hash, NULL );
+			HMAC_Init_ex( ctx_prf, ph1->tunnel->peer->psk.buff(), ( int ) ph1->tunnel->peer->psk.size(), ph1->evp_hash, NULL );
 
 			if( ph1->initiator )
 			{
-				HMAC_Update( &ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
-				HMAC_Update( &ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
+				HMAC_Update( ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
+				HMAC_Update( ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
 			}
 			else
 			{
-				HMAC_Update( &ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
-				HMAC_Update( &ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
+				HMAC_Update( ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
+				HMAC_Update( ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
 			}
 
-			HMAC_Final( &ctx_prf, skeyid_data, NULL );
+			HMAC_Final( ctx_prf, skeyid_data, NULL );
 
-			HMAC_CTX_cleanup( &ctx_prf );
+			HMAC_CTX_free( ctx_prf );
 
 			break;
 		}
@@ -1704,14 +1704,13 @@ long _IKED::phase1_gen_keys( IDB_PH1 * p
 				nonce.add( ph1->nonce_l );
 			}
 
-			HMAC_CTX ctx_prf;
-			HMAC_CTX_init( &ctx_prf );
+			HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-			HMAC_Init_ex( &ctx_prf, nonce.buff(), ( int ) nonce.size(), ph1->evp_hash, NULL );
-			HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-			HMAC_Final( &ctx_prf, skeyid_data, NULL );
+			HMAC_Init_ex( ctx_prf, nonce.buff(), ( int ) nonce.size(), ph1->evp_hash, NULL );
+			HMAC_Update( ctx_prf, shared.buff(), shared.size() );
+			HMAC_Final( ctx_prf, skeyid_data, NULL );
 
-			HMAC_CTX_cleanup( &ctx_prf );
+			HMAC_CTX_free( ctx_prf );
 
 			break;
 		}	
@@ -1730,15 +1729,14 @@ long _IKED::phase1_gen_keys( IDB_PH1 * p
 	// compute SKEYID_d
 	//
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-	HMAC_Update( &ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) "\0", 1 );
-	HMAC_Final( &ctx_prf, skeyid_data, NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, shared.buff(), shared.size() );
+	HMAC_Update( ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ( unsigned char * ) "\0", 1 );
+	HMAC_Final( ctx_prf, skeyid_data, NULL );
 
 	ph1->skeyid_d.set( skeyid_data, skeyid_size );
 
@@ -1753,13 +1751,13 @@ long _IKED::phase1_gen_keys( IDB_PH1 * p
 	// compute SKEYID_a
 	//
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, skeyid_data, skeyid_size );
-	HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-	HMAC_Update( &ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) "\1", 1 );
-	HMAC_Final( &ctx_prf, skeyid_data, NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, skeyid_data, skeyid_size );
+	HMAC_Update( ctx_prf, shared.buff(), shared.size() );
+	HMAC_Update( ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ( unsigned char * ) "\1", 1 );
+	HMAC_Final( ctx_prf, skeyid_data, NULL );
 
 	ph1->skeyid_a.set( skeyid_data, skeyid_size );
 
@@ -1774,13 +1772,13 @@ long _IKED::phase1_gen_keys( IDB_PH1 * p
 	// compute SKEYID_e
 	//
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, skeyid_data, skeyid_size );
-	HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-	HMAC_Update( &ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) "\2", 1 );
-	HMAC_Final( &ctx_prf, skeyid_data, NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, skeyid_data, skeyid_size );
+	HMAC_Update( ctx_prf, shared.buff(), shared.size() );
+	HMAC_Update( ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ( unsigned char * ) "\2", 1 );
+	HMAC_Final( ctx_prf, skeyid_data, NULL );
 
 	ph1->skeyid_e.set( skeyid_data, skeyid_size );
 
@@ -1821,15 +1819,15 @@ long _IKED::phase1_gen_keys( IDB_PH1 * p
 
 		// create extended key data
 
-		HMAC_Init_ex( &ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
-		HMAC_Update( &ctx_prf, ( unsigned char * ) "\0", 1 );
-		HMAC_Final( &ctx_prf, key_data, NULL );
+		HMAC_Init_ex( ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
+		HMAC_Update( ctx_prf, ( unsigned char * ) "\0", 1 );
+		HMAC_Final( ctx_prf, key_data, NULL );
 
 		for( long size = skeyid_size; size < key_size; size += skeyid_size )
 		{
-			HMAC_Init_ex( &ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
-			HMAC_Update( &ctx_prf, key_data + size - skeyid_size, skeyid_size );
-			HMAC_Final( &ctx_prf, key_data + size, NULL );
+			HMAC_Init_ex( ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
+			HMAC_Update( ctx_prf, key_data + size - skeyid_size, skeyid_size );
+			HMAC_Final( ctx_prf, key_data + size, NULL );
 		}
 	}
 	else
@@ -1839,7 +1837,7 @@ long _IKED::phase1_gen_keys( IDB_PH1 * p
 		memcpy( key_data, skeyid_data, key_size );
 	}
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	if( proposal->ciph_kl )
 		key_size = ( proposal->ciph_kl + 7 ) / 8;
@@ -1860,22 +1858,22 @@ long _IKED::phase1_gen_keys( IDB_PH1 * p
 	unsigned char iv_data[ HMAC_MAX_MD_CBLOCK ];
 	unsigned long iv_size = EVP_CIPHER_iv_length( ph1->evp_cipher );
 
-	EVP_MD_CTX ctx_hash;
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
+	EVP_MD_CTX * ctx_hash = EVP_MD_CTX_new();
+	EVP_DigestInit( ctx_hash, ph1->evp_hash );
 
 	if( ph1->initiator )
 	{
-		EVP_DigestUpdate( &ctx_hash, ph1->xl.buff(), ph1->xl.size() );
-		EVP_DigestUpdate( &ctx_hash, ph1->xr.buff(), ph1->xr.size() );
+		EVP_DigestUpdate( ctx_hash, ph1->xl.buff(), ph1->xl.size() );
+		EVP_DigestUpdate( ctx_hash, ph1->xr.buff(), ph1->xr.size() );
 	}
 	else
 	{
-		EVP_DigestUpdate( &ctx_hash, ph1->xr.buff(), ph1->xr.size() );
-		EVP_DigestUpdate( &ctx_hash, ph1->xl.buff(), ph1->xl.size() );
+		EVP_DigestUpdate( ctx_hash, ph1->xr.buff(), ph1->xr.size() );
+		EVP_DigestUpdate( ctx_hash, ph1->xl.buff(), ph1->xl.size() );
 	}
 
-	EVP_DigestFinal( &ctx_hash, iv_data, NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	EVP_DigestFinal( ctx_hash, iv_data, NULL );
+	EVP_MD_CTX_free( ctx_hash );
 
 	ph1->iv.set( iv_data, iv_size );
 
@@ -1903,29 +1901,28 @@ long _IKED::phase1_gen_hash_i( IDB_PH1 *
 
 	hash.size( sa->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new ();
 
-	HMAC_Init_ex( &ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
+	HMAC_Init_ex( ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
 
 	if( sa->initiator )
 	{
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf, sa->xr.buff(), sa->xr.size() );
 	}
 	else
 	{
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf, sa->xl.buff(), sa->xl.size() );
 	}
 
-	HMAC_Update( &ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->hda.buff(), sa->hda.size() );
-	HMAC_Update( &ctx_prf, sa->idi.buff(), sa->idi.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	HMAC_Update( ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, sa->hda.buff(), sa->hda.size() );
+	HMAC_Update( ctx_prf, sa->idi.buff(), sa->idi.size() );
+	HMAC_Final( ctx_prf, hash.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1945,29 +1942,28 @@ long _IKED::phase1_gen_hash_r( IDB_PH1 *
 
 	hash.size( sa->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
+	HMAC_Init_ex( ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
 
 	if( sa->initiator )
 	{
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf, sa->xl.buff(), sa->xl.size() );
 	}
 	else
 	{
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf, sa->xr.buff(), sa->xr.size() );
 	}
 
-	HMAC_Update( &ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->hda.buff(), sa->hda.size() );
-	HMAC_Update( &ctx_prf, sa->idr.buff(), sa->idr.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	HMAC_Update( ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, sa->hda.buff(), sa->hda.size() );
+	HMAC_Update( ctx_prf, sa->idr.buff(), sa->idr.size() );
+	HMAC_Final( ctx_prf, hash.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -2569,14 +2565,14 @@ long _IKED::phase1_gen_natd( IDB_PH1 * p
 	// hash for remote address
 	//
 
-	EVP_MD_CTX ctx_hash;
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_addr.s_addr, 4 );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_port, 2 );
-	EVP_DigestFinal( &ctx_hash, natd.buff(), NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	EVP_MD_CTX * ctx_hash = EVP_MD_CTX_new();
+	EVP_DigestInit( ctx_hash, ph1->evp_hash );
+	EVP_DigestUpdate( ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_addr.s_addr, 4 );
+	EVP_DigestUpdate( ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_port, 2 );
+	EVP_DigestFinal( ctx_hash, natd.buff(), NULL );
+	EVP_MD_CTX_reset( ctx_hash );
 
 	ph1->natd_hash_l.add( natd );
 
@@ -2585,13 +2581,13 @@ long _IKED::phase1_gen_natd( IDB_PH1 * p
 	// hash for local address
 	//
 
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_addr.s_addr, 4 );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_port, 2 );
-	EVP_DigestFinal( &ctx_hash, natd.buff(), NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	EVP_DigestInit( ctx_hash, ph1->evp_hash );
+	EVP_DigestUpdate( ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_addr.s_addr, 4 );
+	EVP_DigestUpdate( ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_port, 2 );
+	EVP_DigestFinal( ctx_hash, natd.buff(), NULL );
+	EVP_MD_CTX_free( ctx_hash );
 
 	ph1->natd_hash_l.add( natd );
 
--- ike.orig/source/iked/ike.idb.phase2.cpp
+++ ike/source/iked/ike.idb.phase2.cpp
@@ -438,7 +438,9 @@ bool _IDB_PH2::setup_dhgrp()
 		}
 
 		xl.size( dh_size );
-		long result = BN_bn2bin( dh->pub_key, xl.buff() );
+		const BIGNUM * pub_key;
+		DH_get0_key( dh, &pub_key, nullptr );
+		long result = BN_bn2bin( pub_key, xl.buff() );
 
 		//
 		// fixup public buffer alignment
--- ike.orig/source/iked/ike.idb.phase1.cpp
+++ ike/source/iked/ike.idb.phase1.cpp
@@ -676,7 +676,9 @@ bool _IDB_PH1::setup_dhgrp( IKE_PROPOSAL
 	}
 
 	xl.size( dh_size );
-	long result = BN_bn2bin( dh->pub_key, xl.buff() );
+	const BIGNUM * pub_key;
+	DH_get0_key( dh, &pub_key, nullptr);
+	long result = BN_bn2bin( pub_key, xl.buff() );
 
 	//
 	// fixup public buffer alignment
--- ike.orig/source/iked/ike.idb.exch.cpp
+++ ike/source/iked/ike.idb.exch.cpp
@@ -134,12 +134,12 @@ bool _IDB_XCH::new_msgiv( IDB_PH1 * ph1
 	unsigned char iv_data[ EVP_MAX_MD_SIZE ];
 	unsigned long iv_size = EVP_CIPHER_iv_length( ph1->evp_cipher );
 
-	EVP_MD_CTX ctx_hash;
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
-	EVP_DigestUpdate( &ctx_hash, ph1->iv.buff(), ph1->iv.size() );
-	EVP_DigestUpdate( &ctx_hash, &msgid, 4 );
-	EVP_DigestFinal( &ctx_hash, iv_data, NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	EVP_MD_CTX * ctx_hash = EVP_MD_CTX_new();
+	EVP_DigestInit( ctx_hash, ph1->evp_hash );
+	EVP_DigestUpdate( ctx_hash, ph1->iv.buff(), ph1->iv.size() );
+	EVP_DigestUpdate( ctx_hash, &msgid, 4 );
+	EVP_DigestFinal( ctx_hash, iv_data, NULL );
+	EVP_MD_CTX_free( ctx_hash );
 
 	iv.set( iv_data, iv_size );
 
--- ike.orig/source/iked/ike.keyfile.cpp
+++ ike/source/iked/ike.keyfile.cpp
@@ -100,8 +100,12 @@ bool bdata_2_cert( X509 ** x509, BDATA &
 	return true;
 }
 
-bool prvkey_rsa_2_bdata( BDATA & prvkey, RSA * rsa )
+bool prvkey_rsa_2_bdata( BDATA & prvkey, EVP_PKEY * evp_pkey )
 {
+	const RSA * rsa = EVP_PKEY_get0_RSA(evp_pkey);
+	if (!rsa)
+		return false;
+
 	int size = i2d_RSAPrivateKey( rsa, NULL );
 	prvkey.size( size );
 
@@ -123,8 +127,12 @@ bool bdata_2_prvkey_rsa( RSA ** rsa, BDA
 	return true;
 }
 
-bool pubkey_rsa_2_bdata( BDATA & pubkey, RSA * rsa )
+bool pubkey_rsa_2_bdata( BDATA & pubkey, EVP_PKEY * evp_pkey )
 {
+	const RSA * rsa = EVP_PKEY_get0_RSA(evp_pkey);
+	if (!rsa)
+		return false;
+
 	int size = i2d_RSAPublicKey( rsa, NULL );
 	pubkey.size( size );
 
@@ -664,14 +672,14 @@ static int verify_cb( int ok, X509_STORE
 		long ll = LLOG_ERROR;
 		char name[ 512 ];
 
-		X509_NAME * x509_name = X509_get_subject_name( store_ctx->current_cert );
+		X509_NAME * x509_name = X509_get_subject_name( X509_STORE_CTX_get_current_cert( store_ctx ) );
 
 		X509_NAME_oneline(
 			x509_name,
 			name,
 			512 );
 
-		switch( store_ctx->error )
+		switch( X509_STORE_CTX_get_error( store_ctx ) )
 		{
 			case X509_V_ERR_UNABLE_TO_GET_CRL:
 				ok = 1;
@@ -683,9 +691,9 @@ static int verify_cb( int ok, X509_STORE
 			ll,
 			"ii : %s(%d) at depth:%d\n"
 			"ii : subject :%s\n",
-			X509_verify_cert_error_string( store_ctx->error ),
-			store_ctx->error,
-			store_ctx->error_depth,
+			X509_verify_cert_error_string( X509_STORE_CTX_get_error( store_ctx ) ),
+			X509_STORE_CTX_get_error( store_ctx ),
+			X509_STORE_CTX_get_error_depth( store_ctx ),
 			name );
 	}
 
@@ -857,7 +865,7 @@ bool prvkey_rsa_load_pem( BDATA & prvkey
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -883,7 +891,7 @@ bool prvkey_rsa_load_p12( BDATA & prvkey
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -939,7 +947,7 @@ bool prvkey_rsa_load_pem( BDATA & prvkey
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -976,7 +984,7 @@ bool prvkey_rsa_load_p12( BDATA & prvkey
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -1010,7 +1018,7 @@ bool _IKED::pubkey_rsa_read( BDATA & cer
 	if( evp_pkey == NULL )
 		return false;
 
-	bool result = pubkey_rsa_2_bdata( pubkey, evp_pkey->pkey.rsa );
+	bool result = pubkey_rsa_2_bdata( pubkey, evp_pkey );
 
 	EVP_PKEY_free( evp_pkey );
 
