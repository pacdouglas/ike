From: Sam Morris <sam@robots.org.uk>
Date: Fri, 20 Jul 2018 12:04:16 +0100
Subject: openssl-1.1-port

---
 source/iked/crypto.cpp          |  87 ++++++++--------
 source/iked/ike.cpp             |  30 +++---
 source/iked/ike.exch.config.cpp |  32 +++---
 source/iked/ike.exch.inform.cpp |  31 +++---
 source/iked/ike.exch.phase1.cpp | 214 ++++++++++++++++++++--------------------
 source/iked/ike.exch.phase2.cpp |  90 ++++++++---------
 source/iked/ike.idb.exch.cpp    |  16 +--
 source/iked/ike.idb.phase1.cpp  |   4 +-
 source/iked/ike.idb.phase2.cpp  |   4 +-
 source/iked/ike.keyfile.cpp     |  32 +++---
 source/libike/manager.file.cpp  |  12 ++-
 11 files changed, 286 insertions(+), 266 deletions(-)

diff --git a/source/iked/crypto.cpp b/source/iked/crypto.cpp
index 421e34f..9bac314 100644
--- a/source/iked/crypto.cpp
+++ b/source/iked/crypto.cpp
@@ -39,6 +39,8 @@
  *
  */
 
+#include <memory>
+
 #include "crypto.h"
 
 void crypto_init()
@@ -372,97 +374,92 @@ static unsigned char group18[] =
 
 bool dh_init( long group, DH ** dh_data, long * dh_size )
 {
-	DH * dh = DH_new();
-	if( dh == NULL )
+	std::unique_ptr<DH, decltype(&DH_free)> dh {DH_new(), DH_free};
+	if( !dh )
 		return false;
 
-	dh->p = NULL;
-	dh->g = NULL;
-	dh->length = 0;
-
 	//
 	// set p ( prime ) value
 	//
 
-	unsigned char * p_data = NULL;
-	size_t			p_size = 0;
-
-	dh->p = BN_new();
-	if( dh->p == NULL )
-		goto dh_failed;
+	std::unique_ptr<BIGNUM, decltype(&BN_clear_free)> dh_p {BN_new(), BN_clear_free};
+	if( !dh_p )
+		return false;
 
 	switch( group )
 	{
 		case 1:
-			if( !BN_bin2bn( group1, sizeof( group1 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group1, sizeof( group1 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 2:
-			if( !BN_bin2bn( group2, sizeof( group2 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group2, sizeof( group2 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 5:
-			if( !BN_bin2bn( group5, sizeof( group5 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group5, sizeof( group5 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 14:
-			if( !BN_bin2bn( group14, sizeof( group14 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group14, sizeof( group14 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 15:
-			if( !BN_bin2bn( group15, sizeof( group15 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group15, sizeof( group15 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 16:
-			if( !BN_bin2bn( group16, sizeof( group16 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group16, sizeof( group16 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 17:
-			if( !BN_bin2bn( group17, sizeof( group17 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group17, sizeof( group17 ), dh_p.get() ) )
+				return false;
 			break;
 
 		case 18:
-			if( !BN_bin2bn( group18, sizeof( group18 ), dh->p ) )
-				goto dh_failed;
+			if( !BN_bin2bn( group18, sizeof( group18 ), dh_p.get() ) )
+				return false;
 			break;
 
 		default:
-			goto dh_failed;
+			return false;
 	}
 
 	//
 	// set g ( generator ) value
 	//
 
-	dh->g = BN_new();
-	if( dh->g == NULL )
-		goto dh_failed;
+	std::unique_ptr<BIGNUM, decltype(&BN_clear_free)> dh_g {BN_new(), BN_clear_free};
+	if( !dh_g )
+		return false;
+
+	if( !BN_set_word( dh_g.get(), 2 ) )
+		return false;
 
-	if( !BN_set_word( dh->g, 2 ) )
-		goto dh_failed;
+	if( DH_set0_pqg (dh.get(), dh_p.get(), dh_g.get(), nullptr) ) {
+		dh_p.release();
+		dh_g.release();
+	}
 
 	//
 	// generate private and public DH values
 	//
 
-	if( !DH_generate_key( dh ) )
-		goto dh_failed;
-
-	*dh_data = dh;
-	*dh_size = BN_num_bytes( dh->p );
+	if( !DH_generate_key( dh.get() ) )
+		return false;
 
+	{
+		const BIGNUM * p;
+		DH_get0_pqg ( dh.get(), &p, nullptr, nullptr );
+		*dh_size = BN_num_bytes( p );
+	}
+	*dh_data = dh.release();
 	return true;
-
-	dh_failed:
-
-	DH_free( dh );
-
-	return false;
 }
diff --git a/source/iked/ike.cpp b/source/iked/ike.cpp
index 1ad6a44..ca3acc4 100644
--- a/source/iked/ike.cpp
+++ b/source/iked/ike.cpp
@@ -391,11 +391,12 @@ long _IKED::packet_ike_decrypt( IDB_PH1 * sa, PACKET_IKE & packet, BDATA * iv )
 	// init cipher key and iv
 	//
 
-	EVP_CIPHER_CTX ctx_cipher;
-	EVP_CIPHER_CTX_init( &ctx_cipher );
+	EVP_CIPHER_CTX * ctx_cipher = EVP_CIPHER_CTX_new();
+	if (!ctx_cipher)
+		return LIBIKE_MEMORY;
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		sa->evp_cipher,
 		NULL,
 		NULL,
@@ -403,11 +404,11 @@ long _IKED::packet_ike_decrypt( IDB_PH1 * sa, PACKET_IKE & packet, BDATA * iv )
 		0 );
 
 	EVP_CIPHER_CTX_set_key_length(
-		&ctx_cipher,
+		ctx_cipher,
 		( int ) sa->key.size() );
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		NULL,
 		NULL,
 		sa->key.buff(),
@@ -419,12 +420,12 @@ long _IKED::packet_ike_decrypt( IDB_PH1 * sa, PACKET_IKE & packet, BDATA * iv )
 	//
 
 	EVP_Cipher(
-		&ctx_cipher,
+		ctx_cipher,
 		data + sizeof( IKE_HEADER ),
 		data + sizeof( IKE_HEADER ),
 		( int ) size - sizeof( IKE_HEADER ) );
 
-	EVP_CIPHER_CTX_cleanup( &ctx_cipher );
+	EVP_CIPHER_CTX_free( ctx_cipher );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -595,11 +596,12 @@ long _IKED::packet_ike_encrypt( IDB_PH1 * sa, PACKET_IKE & packet, BDATA * iv )
 	// encrypt all but header
 	//
 
-	EVP_CIPHER_CTX ctx_cipher;
-	EVP_CIPHER_CTX_init( &ctx_cipher );
+	EVP_CIPHER_CTX * ctx_cipher = EVP_CIPHER_CTX_new();
+	if (!ctx_cipher)
+		return LIBIKE_MEMORY;
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		sa->evp_cipher,
 		NULL,
 		NULL,
@@ -607,11 +609,11 @@ long _IKED::packet_ike_encrypt( IDB_PH1 * sa, PACKET_IKE & packet, BDATA * iv )
 		1 );
 
 	EVP_CIPHER_CTX_set_key_length(
-		&ctx_cipher,
+		ctx_cipher,
 		( int ) sa->key.size() );
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		NULL,
 		NULL,
 		sa->key.buff(),
@@ -619,13 +621,11 @@ long _IKED::packet_ike_encrypt( IDB_PH1 * sa, PACKET_IKE & packet, BDATA * iv )
 		1 );
 
 	EVP_Cipher(
-		&ctx_cipher,
+		ctx_cipher,
 		data + sizeof( IKE_HEADER ),
 		data + sizeof( IKE_HEADER ),
 		( int ) size - sizeof( IKE_HEADER ) );
 
-	EVP_CIPHER_CTX_cleanup( &ctx_cipher );
-
 	//
 	// store cipher iv data
 	//
diff --git a/source/iked/ike.exch.config.cpp b/source/iked/ike.exch.config.cpp
index a9390e7..1f23fbd 100644
--- a/source/iked/ike.exch.config.cpp
+++ b/source/iked/ike.exch.config.cpp
@@ -39,6 +39,8 @@
  *
  */
 
+#include <memory>
+
 #include "iked.h"
 
 long _IKED::process_config_recv( IDB_PH1 * ph1, PACKET_IKE & packet, unsigned char payload )
@@ -2481,15 +2483,14 @@ long _IKED::config_chk_hash( IDB_PH1 * ph1, IDB_CFG * cfg, unsigned long msgid )
 	BDATA hash_c;
 	hash_c.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
-
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &msgid, 4 );
-	HMAC_Update( &ctx_prf, cfg->hda.buff(), cfg->hda.size() );
-	HMAC_Final( &ctx_prf, hash_c.buff(), NULL );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), ( unsigned char * ) &msgid, 4 );
+	HMAC_Update( ctx_prf.get(), cfg->hda.buff(), cfg->hda.size() );
+	HMAC_Final( ctx_prf.get(), hash_c.buff(), NULL );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -2543,15 +2544,14 @@ long _IKED::config_message_send( IDB_PH1 * ph1, IDB_CFG * cfg )
 	// create message authentication hash
 	//
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
-
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &cfg->msgid, sizeof( cfg->msgid ) );
-	HMAC_Update( &ctx_prf, packet.buff() + beg, end - beg );
-	HMAC_Final( &ctx_prf, hash.buff(), 0 );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), ( unsigned char * ) &cfg->msgid, sizeof( cfg->msgid ) );
+	HMAC_Update( ctx_prf.get(), packet.buff() + beg, end - beg );
+	HMAC_Final( ctx_prf.get(), hash.buff(), 0 );
 
 	memcpy( packet.buff() + off + 4, hash.buff(), hash.size() );
 
diff --git a/source/iked/ike.exch.inform.cpp b/source/iked/ike.exch.inform.cpp
index 07d963b..565659b 100644
--- a/source/iked/ike.exch.inform.cpp
+++ b/source/iked/ike.exch.inform.cpp
@@ -39,6 +39,8 @@
  *
  */
 
+#include <memory>
+
 #include "iked.h"
 
 long _IKED::process_inform_send( IDB_PH1 * ph1, IDB_XCH * inform )
@@ -399,15 +401,15 @@ long _IKED::inform_chk_hash( IDB_PH1 * ph1, IDB_XCH * inform )
 	BDATA hash_c;
 	hash_c.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &inform->msgid, 4 );
-	HMAC_Update( &ctx_prf, inform->hda.buff(), inform->hda.size() );
-	HMAC_Final( &ctx_prf, hash_c.buff(), NULL );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), ( unsigned char * ) &inform->msgid, 4 );
+	HMAC_Update( ctx_prf.get(), inform->hda.buff(), inform->hda.size() );
+	HMAC_Final( ctx_prf.get(), hash_c.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -439,15 +441,14 @@ long _IKED::inform_gen_hash( IDB_PH1 * ph1, IDB_XCH * inform )
 {
 	inform->hash_l.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
-
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &inform->msgid, sizeof( inform->msgid ) );
-	HMAC_Update( &ctx_prf, inform->hda.buff(), inform->hda.size() );
-	HMAC_Final( &ctx_prf, inform->hash_l.buff(), 0 );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), ( unsigned char * ) &inform->msgid, sizeof( inform->msgid ) );
+	HMAC_Update( ctx_prf.get(), inform->hda.buff(), inform->hda.size() );
+	HMAC_Final( ctx_prf.get(), inform->hash_l.buff(), 0 );
 
 	log.bin(
 		LLOG_DEBUG,
diff --git a/source/iked/ike.exch.phase1.cpp b/source/iked/ike.exch.phase1.cpp
index 47fe020..3445f26 100644
--- a/source/iked/ike.exch.phase1.cpp
+++ b/source/iked/ike.exch.phase1.cpp
@@ -39,6 +39,8 @@
  *
  */
 
+#include <memory>
+
 #include "iked.h"
 
 long _IKED::process_phase1_recv( IDB_PH1 * ph1, PACKET_IKE & packet, unsigned char payload )
@@ -1044,14 +1046,13 @@ long _IKED::process_phase1_send( IDB_PH1 * ph1 )
 								BDATA psk_hash;
 								psk_hash.size( ph1->hash_size );
 
-								HMAC_CTX ctx_prf;
-								HMAC_CTX_init( &ctx_prf );
-
-								HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-								HMAC_Update( &ctx_prf, ph1->tunnel->peer->psk.buff(), ph1->tunnel->peer->psk.size() );
-								HMAC_Final( &ctx_prf, psk_hash.buff(), NULL );
+								std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+								if (!ctx_prf)
+									return LIBIKE_FAILED;
 
-								HMAC_CTX_cleanup( &ctx_prf );
+								HMAC_Init_ex( ctx_prf.get(), ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+								HMAC_Update( ctx_prf.get(), ph1->tunnel->peer->psk.buff(), ph1->tunnel->peer->psk.size() );
+								HMAC_Final( ctx_prf.get(), psk_hash.buff(), NULL );
 
 								//
 								// add the notification payload
@@ -1557,7 +1558,9 @@ long _IKED::phase1_gen_keys( IDB_PH1 * ph1 )
 	{
 		BDATA prv;
 		prv.size( ph1->dh_size );
-		BN_bn2bin( ph1->dh->priv_key, prv.buff() );
+		const BIGNUM * priv_key;
+		DH_get0_key (ph1->dh, nullptr, &priv_key);
+		BN_bn2bin( priv_key, prv.buff() );
 
 		log.bin(
 			LLOG_DECODE,
@@ -1656,25 +1659,24 @@ long _IKED::phase1_gen_keys( IDB_PH1 * ph1 )
 		case XAUTH_AUTH_INIT_PSK:
 		case XAUTH_AUTH_RESP_PSK:
 		{
-			HMAC_CTX ctx_prf;
-			HMAC_CTX_init( &ctx_prf );
+			std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+			if (!ctx_prf)
+				return LIBIKE_MEMORY;
 
-			HMAC_Init_ex( &ctx_prf, ph1->tunnel->peer->psk.buff(), ( int ) ph1->tunnel->peer->psk.size(), ph1->evp_hash, NULL );
+			HMAC_Init_ex( ctx_prf.get(), ph1->tunnel->peer->psk.buff(), ( int ) ph1->tunnel->peer->psk.size(), ph1->evp_hash, NULL );
 
 			if( ph1->initiator )
 			{
-				HMAC_Update( &ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
-				HMAC_Update( &ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
+				HMAC_Update( ctx_prf.get(), ph1->nonce_l.buff(), ph1->nonce_l.size() );
+				HMAC_Update( ctx_prf.get(), ph1->nonce_r.buff(), ph1->nonce_r.size() );
 			}
 			else
 			{
-				HMAC_Update( &ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
-				HMAC_Update( &ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
+				HMAC_Update( ctx_prf.get(), ph1->nonce_r.buff(), ph1->nonce_r.size() );
+				HMAC_Update( ctx_prf.get(), ph1->nonce_l.buff(), ph1->nonce_l.size() );
 			}
 
-			HMAC_Final( &ctx_prf, skeyid_data, NULL );
-
-			HMAC_CTX_cleanup( &ctx_prf );
+			HMAC_Final( ctx_prf.get(), skeyid_data, NULL );
 
 			break;
 		}
@@ -1704,14 +1706,13 @@ long _IKED::phase1_gen_keys( IDB_PH1 * ph1 )
 				nonce.add( ph1->nonce_l );
 			}
 
-			HMAC_CTX ctx_prf;
-			HMAC_CTX_init( &ctx_prf );
-
-			HMAC_Init_ex( &ctx_prf, nonce.buff(), ( int ) nonce.size(), ph1->evp_hash, NULL );
-			HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-			HMAC_Final( &ctx_prf, skeyid_data, NULL );
+			std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+			if (!ctx_prf)
+				return LIBIKE_MEMORY;
 
-			HMAC_CTX_cleanup( &ctx_prf );
+			HMAC_Init_ex( ctx_prf.get(), nonce.buff(), ( int ) nonce.size(), ph1->evp_hash, NULL );
+			HMAC_Update( ctx_prf.get(), shared.buff(), shared.size() );
+			HMAC_Final( ctx_prf.get(), skeyid_data, NULL );
 
 			break;
 		}	
@@ -1730,15 +1731,16 @@ long _IKED::phase1_gen_keys( IDB_PH1 * ph1 )
 	// compute SKEYID_d
 	//
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-	HMAC_Update( &ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) "\0", 1 );
-	HMAC_Final( &ctx_prf, skeyid_data, NULL );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), shared.buff(), shared.size() );
+	HMAC_Update( ctx_prf.get(), ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), ( unsigned char * ) "\0", 1 );
+	HMAC_Final( ctx_prf.get(), skeyid_data, NULL );
 
 	ph1->skeyid_d.set( skeyid_data, skeyid_size );
 
@@ -1753,13 +1755,13 @@ long _IKED::phase1_gen_keys( IDB_PH1 * ph1 )
 	// compute SKEYID_a
 	//
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, skeyid_data, skeyid_size );
-	HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-	HMAC_Update( &ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) "\1", 1 );
-	HMAC_Final( &ctx_prf, skeyid_data, NULL );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), skeyid_data, skeyid_size );
+	HMAC_Update( ctx_prf.get(), shared.buff(), shared.size() );
+	HMAC_Update( ctx_prf.get(), ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), ( unsigned char * ) "\1", 1 );
+	HMAC_Final( ctx_prf.get(), skeyid_data, NULL );
 
 	ph1->skeyid_a.set( skeyid_data, skeyid_size );
 
@@ -1774,13 +1776,13 @@ long _IKED::phase1_gen_keys( IDB_PH1 * ph1 )
 	// compute SKEYID_e
 	//
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, skeyid_data, skeyid_size );
-	HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-	HMAC_Update( &ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) "\2", 1 );
-	HMAC_Final( &ctx_prf, skeyid_data, NULL );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), skeyid_data, skeyid_size );
+	HMAC_Update( ctx_prf.get(), shared.buff(), shared.size() );
+	HMAC_Update( ctx_prf.get(), ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), ( unsigned char * ) "\2", 1 );
+	HMAC_Final( ctx_prf.get(), skeyid_data, NULL );
 
 	ph1->skeyid_e.set( skeyid_data, skeyid_size );
 
@@ -1821,15 +1823,15 @@ long _IKED::phase1_gen_keys( IDB_PH1 * ph1 )
 
 		// create extended key data
 
-		HMAC_Init_ex( &ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
-		HMAC_Update( &ctx_prf, ( unsigned char * ) "\0", 1 );
-		HMAC_Final( &ctx_prf, key_data, NULL );
+		HMAC_Init_ex( ctx_prf.get(), skeyid_data, skeyid_size, ph1->evp_hash, NULL );
+		HMAC_Update( ctx_prf.get(), ( unsigned char * ) "\0", 1 );
+		HMAC_Final( ctx_prf.get(), key_data, NULL );
 
 		for( long size = skeyid_size; size < key_size; size += skeyid_size )
 		{
-			HMAC_Init_ex( &ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
-			HMAC_Update( &ctx_prf, key_data + size - skeyid_size, skeyid_size );
-			HMAC_Final( &ctx_prf, key_data + size, NULL );
+			HMAC_Init_ex( ctx_prf.get(), skeyid_data, skeyid_size, ph1->evp_hash, NULL );
+			HMAC_Update( ctx_prf.get(), key_data + size - skeyid_size, skeyid_size );
+			HMAC_Final( ctx_prf.get(), key_data + size, NULL );
 		}
 	}
 	else
@@ -1839,8 +1841,6 @@ long _IKED::phase1_gen_keys( IDB_PH1 * ph1 )
 		memcpy( key_data, skeyid_data, key_size );
 	}
 
-	HMAC_CTX_cleanup( &ctx_prf );
-
 	if( proposal->ciph_kl )
 		key_size = ( proposal->ciph_kl + 7 ) / 8;
 
@@ -1860,22 +1860,24 @@ long _IKED::phase1_gen_keys( IDB_PH1 * ph1 )
 	unsigned char iv_data[ HMAC_MAX_MD_CBLOCK ];
 	unsigned long iv_size = EVP_CIPHER_iv_length( ph1->evp_cipher );
 
-	EVP_MD_CTX ctx_hash;
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
+	std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)> ctx_hash {EVP_MD_CTX_new(), EVP_MD_CTX_free};
+	if (!ctx_hash)
+		return LIBIKE_MEMORY;
+
+	EVP_DigestInit( ctx_hash.get(), ph1->evp_hash );
 
 	if( ph1->initiator )
 	{
-		EVP_DigestUpdate( &ctx_hash, ph1->xl.buff(), ph1->xl.size() );
-		EVP_DigestUpdate( &ctx_hash, ph1->xr.buff(), ph1->xr.size() );
+		EVP_DigestUpdate( ctx_hash.get(), ph1->xl.buff(), ph1->xl.size() );
+		EVP_DigestUpdate( ctx_hash.get(), ph1->xr.buff(), ph1->xr.size() );
 	}
 	else
 	{
-		EVP_DigestUpdate( &ctx_hash, ph1->xr.buff(), ph1->xr.size() );
-		EVP_DigestUpdate( &ctx_hash, ph1->xl.buff(), ph1->xl.size() );
+		EVP_DigestUpdate( ctx_hash.get(), ph1->xr.buff(), ph1->xr.size() );
+		EVP_DigestUpdate( ctx_hash.get(), ph1->xl.buff(), ph1->xl.size() );
 	}
 
-	EVP_DigestFinal( &ctx_hash, iv_data, NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	EVP_DigestFinal( ctx_hash.get(), iv_data, NULL );
 
 	ph1->iv.set( iv_data, iv_size );
 
@@ -1903,29 +1905,28 @@ long _IKED::phase1_gen_hash_i( IDB_PH1 * sa, BDATA & hash )
 
 	hash.size( sa->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_Init_ex( &ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
+	HMAC_Init_ex( ctx_prf.get(), sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
 
 	if( sa->initiator )
 	{
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf.get(), sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf.get(), sa->xr.buff(), sa->xr.size() );
 	}
 	else
 	{
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf.get(), sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf.get(), sa->xl.buff(), sa->xl.size() );
 	}
 
-	HMAC_Update( &ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->hda.buff(), sa->hda.size() );
-	HMAC_Update( &ctx_prf, sa->idi.buff(), sa->idi.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
-
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_Update( ctx_prf.get(), sa->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), sa->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), sa->hda.buff(), sa->hda.size() );
+	HMAC_Update( ctx_prf.get(), sa->idi.buff(), sa->idi.size() );
+	HMAC_Final( ctx_prf.get(), hash.buff(), NULL );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1945,29 +1946,28 @@ long _IKED::phase1_gen_hash_r( IDB_PH1 * sa, BDATA & hash )
 
 	hash.size( sa->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_Init_ex( &ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
+	HMAC_Init_ex( ctx_prf.get(), sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
 
 	if( sa->initiator )
 	{
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf.get(), sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf.get(), sa->xl.buff(), sa->xl.size() );
 	}
 	else
 	{
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf.get(), sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf.get(), sa->xr.buff(), sa->xr.size() );
 	}
 
-	HMAC_Update( &ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->hda.buff(), sa->hda.size() );
-	HMAC_Update( &ctx_prf, sa->idr.buff(), sa->idr.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
-
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_Update( ctx_prf.get(), sa->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), sa->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf.get(), sa->hda.buff(), sa->hda.size() );
+	HMAC_Update( ctx_prf.get(), sa->idr.buff(), sa->idr.size() );
+	HMAC_Final( ctx_prf.get(), hash.buff(), NULL );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -2569,14 +2569,17 @@ long _IKED::phase1_gen_natd( IDB_PH1 * ph1 )
 	// hash for remote address
 	//
 
-	EVP_MD_CTX ctx_hash;
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_addr.s_addr, 4 );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_port, 2 );
-	EVP_DigestFinal( &ctx_hash, natd.buff(), NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)> ctx_hash {EVP_MD_CTX_new(), EVP_MD_CTX_free};
+	if (!ctx_hash)
+		return LIBIKE_MEMORY;
+
+	EVP_DigestInit( ctx_hash.get(), ph1->evp_hash );
+	EVP_DigestUpdate( ctx_hash.get(), ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash.get(), ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash.get(), &ph1->tunnel->saddr_r.saddr4.sin_addr.s_addr, 4 );
+	EVP_DigestUpdate( ctx_hash.get(), &ph1->tunnel->saddr_r.saddr4.sin_port, 2 );
+	EVP_DigestFinal( ctx_hash.get(), natd.buff(), NULL );
+	EVP_MD_CTX_reset( ctx_hash.get() );
 
 	ph1->natd_hash_l.add( natd );
 
@@ -2585,13 +2588,12 @@ long _IKED::phase1_gen_natd( IDB_PH1 * ph1 )
 	// hash for local address
 	//
 
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_addr.s_addr, 4 );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_port, 2 );
-	EVP_DigestFinal( &ctx_hash, natd.buff(), NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	EVP_DigestInit( ctx_hash.get(), ph1->evp_hash );
+	EVP_DigestUpdate( ctx_hash.get(), ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash.get(), ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash.get(), &ph1->tunnel->saddr_l.saddr4.sin_addr.s_addr, 4 );
+	EVP_DigestUpdate( ctx_hash.get(), &ph1->tunnel->saddr_l.saddr4.sin_port, 2 );
+	EVP_DigestFinal( ctx_hash.get(), natd.buff(), NULL );
 
 	ph1->natd_hash_l.add( natd );
 
diff --git a/source/iked/ike.exch.phase2.cpp b/source/iked/ike.exch.phase2.cpp
index 19a5ad5..76bfd96 100644
--- a/source/iked/ike.exch.phase2.cpp
+++ b/source/iked/ike.exch.phase2.cpp
@@ -39,6 +39,8 @@
  *
  */
 
+#include <memory>
+
 #include "iked.h"
 
 long _IKED::process_phase2_recv( IDB_PH1 * ph1, PACKET_IKE & packet, unsigned char payload )
@@ -1008,14 +1010,13 @@ long _IKED::phase2_gen_hash_i( IDB_PH1 * ph1, IDB_PH2 * ph2, BDATA & hash )
 
 	hash.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
-
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, input.buff(), input.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), input.buff(), input.size() );
+	HMAC_Final( ctx_prf.get(), hash.buff(), NULL );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1048,14 +1049,13 @@ long _IKED::phase2_gen_hash_r( IDB_PH1 * ph1, IDB_PH2 * ph2, BDATA & hash )
 
 	hash.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
-
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, input.buff(), input.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), input.buff(), input.size() );
+	HMAC_Final( ctx_prf.get(), hash.buff(), NULL );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1093,14 +1093,13 @@ long _IKED::phase2_gen_hash_p( IDB_PH1 * ph1, IDB_PH2 * ph2, BDATA & hash )
 
 	hash.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, input.buff(), input.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), 0 );
-
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf.get(), input.buff(), input.size() );
+	HMAC_Final( ctx_prf.get(), hash.buff(), 0 );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1555,7 +1554,9 @@ long _IKED::phase2_gen_keys( IDB_PH1 * ph1, IDB_PH2 * ph2 )
 		{
 			BDATA prv;
 			prv.size( ph2->dh_size );
-			BN_bn2bin( ph2->dh->priv_key, prv.buff() );
+			const BIGNUM * priv_key;
+			DH_get0_key (ph2->dh, nullptr, &priv_key);
+			BN_bn2bin( priv_key, prv.buff() );
 
 			log.bin(
 				LLOG_DECODE,
@@ -1817,57 +1818,56 @@ long _IKED::phase2_gen_keys( IDB_PH1 * ph1, IDB_PH2 * ph2, long dir, IKE_PROPOSA
 	// K3 = prf( SKEYID_d, K2 | [ g(qm)^xy | ] protocol | SPI | Ni_b | Nr_b )
 	//
 	
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	std::unique_ptr<HMAC_CTX, decltype(&HMAC_CTX_free)> ctx_prf {HMAC_CTX_new(), HMAC_CTX_free};
+	if (!ctx_prf)
+		return LIBIKE_MEMORY;
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
+	HMAC_Init_ex( ctx_prf.get(), ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
 
 	if( ph2->dhgr_id )
-		HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
+		HMAC_Update( ctx_prf.get(), shared.buff(), shared.size() );
 
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
+	HMAC_Update( ctx_prf.get(), ( unsigned char * ) &proposal->proto, 1 );
+	HMAC_Update( ctx_prf.get(), ( unsigned char * ) &proposal->spi, 4 );
 
 	if( ph2->initiator )
 	{
-		HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
-		HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+		HMAC_Update( ctx_prf.get(), ph2->nonce_l.buff(), ph2->nonce_l.size() );
+		HMAC_Update( ctx_prf.get(), ph2->nonce_r.buff(), ph2->nonce_r.size() );
 	}
 	else
 	{
-		HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
-		HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+		HMAC_Update( ctx_prf.get(), ph2->nonce_r.buff(), ph2->nonce_r.size() );
+		HMAC_Update( ctx_prf.get(), ph2->nonce_l.buff(), ph2->nonce_l.size() );
 	}
 
-	HMAC_Final( &ctx_prf, key_data, NULL );
+	HMAC_Final( ctx_prf.get(), key_data, NULL );
 
 	for( long size = skeyid_size; size < key_size; size += skeyid_size )
 	{
-		HMAC_Init_ex( &ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
-		HMAC_Update( &ctx_prf, key_data + size - skeyid_size, skeyid_size );
+		HMAC_Init_ex( ctx_prf.get(), ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
+		HMAC_Update( ctx_prf.get(), key_data + size - skeyid_size, skeyid_size );
 
 		if( ph2->dhgr_id )
-			HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
+			HMAC_Update( ctx_prf.get(), shared.buff(), shared.size() );
 
-		HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
-		HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
+		HMAC_Update( ctx_prf.get(), ( unsigned char * ) &proposal->proto, 1 );
+		HMAC_Update( ctx_prf.get(), ( unsigned char * ) &proposal->spi, 4 );
 
 		if( ph2->initiator )
 		{
-			HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
-			HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+			HMAC_Update( ctx_prf.get(), ph2->nonce_l.buff(), ph2->nonce_l.size() );
+			HMAC_Update( ctx_prf.get(), ph2->nonce_r.buff(), ph2->nonce_r.size() );
 		}
 		else
 		{
-			HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
-			HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+			HMAC_Update( ctx_prf.get(), ph2->nonce_r.buff(), ph2->nonce_r.size() );
+			HMAC_Update( ctx_prf.get(), ph2->nonce_l.buff(), ph2->nonce_l.size() );
 		}
 
-		HMAC_Final( &ctx_prf, key_data + size, 0 );
+		HMAC_Final( ctx_prf.get(), key_data + size, 0 );
 	}
 
-	HMAC_CTX_cleanup( &ctx_prf );
-
 	//
 	// separate encrypt and auth key data
 	//
diff --git a/source/iked/ike.idb.exch.cpp b/source/iked/ike.idb.exch.cpp
index d237e41..8ac5b5a 100644
--- a/source/iked/ike.idb.exch.cpp
+++ b/source/iked/ike.idb.exch.cpp
@@ -39,6 +39,8 @@
  *
  */
 
+#include <memory>
+
 #include "iked.h"
 
 //==============================================================================
@@ -134,12 +136,14 @@ bool _IDB_XCH::new_msgiv( IDB_PH1 * ph1 )
 	unsigned char iv_data[ EVP_MAX_MD_SIZE ];
 	unsigned long iv_size = EVP_CIPHER_iv_length( ph1->evp_cipher );
 
-	EVP_MD_CTX ctx_hash;
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
-	EVP_DigestUpdate( &ctx_hash, ph1->iv.buff(), ph1->iv.size() );
-	EVP_DigestUpdate( &ctx_hash, &msgid, 4 );
-	EVP_DigestFinal( &ctx_hash, iv_data, NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)> ctx_hash {EVP_MD_CTX_new(), EVP_MD_CTX_free};
+	if (!ctx_hash)
+		return false; // or abort? clients' don't seem to check the return code anyway...
+
+	EVP_DigestInit( ctx_hash.get(), ph1->evp_hash );
+	EVP_DigestUpdate( ctx_hash.get(), ph1->iv.buff(), ph1->iv.size() );
+	EVP_DigestUpdate( ctx_hash.get(), &msgid, 4 );
+	EVP_DigestFinal( ctx_hash.get(), iv_data, NULL );
 
 	iv.set( iv_data, iv_size );
 
diff --git a/source/iked/ike.idb.phase1.cpp b/source/iked/ike.idb.phase1.cpp
index f3858fc..a64b16f 100644
--- a/source/iked/ike.idb.phase1.cpp
+++ b/source/iked/ike.idb.phase1.cpp
@@ -676,7 +676,9 @@ bool _IDB_PH1::setup_dhgrp( IKE_PROPOSAL * proposal )
 	}
 
 	xl.size( dh_size );
-	long result = BN_bn2bin( dh->pub_key, xl.buff() );
+	const BIGNUM * pub_key;
+	DH_get0_key( dh, &pub_key, nullptr);
+	long result = BN_bn2bin( pub_key, xl.buff() );
 
 	//
 	// fixup public buffer alignment
diff --git a/source/iked/ike.idb.phase2.cpp b/source/iked/ike.idb.phase2.cpp
index 172944c..0ee3dd4 100644
--- a/source/iked/ike.idb.phase2.cpp
+++ b/source/iked/ike.idb.phase2.cpp
@@ -438,7 +438,9 @@ bool _IDB_PH2::setup_dhgrp()
 		}
 
 		xl.size( dh_size );
-		long result = BN_bn2bin( dh->pub_key, xl.buff() );
+		const BIGNUM * pub_key;
+		DH_get0_key( dh, &pub_key, nullptr );
+		long result = BN_bn2bin( pub_key, xl.buff() );
 
 		//
 		// fixup public buffer alignment
diff --git a/source/iked/ike.keyfile.cpp b/source/iked/ike.keyfile.cpp
index c9ea803..eab7821 100644
--- a/source/iked/ike.keyfile.cpp
+++ b/source/iked/ike.keyfile.cpp
@@ -100,8 +100,12 @@ bool bdata_2_cert( X509 ** x509, BDATA & cert )
 	return true;
 }
 
-bool prvkey_rsa_2_bdata( BDATA & prvkey, RSA * rsa )
+bool prvkey_rsa_2_bdata( BDATA & prvkey, EVP_PKEY * evp_pkey )
 {
+	const RSA * rsa = EVP_PKEY_get0_RSA(evp_pkey);
+	if (!rsa)
+		return false;
+
 	int size = i2d_RSAPrivateKey( rsa, NULL );
 	prvkey.size( size );
 
@@ -123,8 +127,12 @@ bool bdata_2_prvkey_rsa( RSA ** rsa, BDATA & prvkey )
 	return true;
 }
 
-bool pubkey_rsa_2_bdata( BDATA & pubkey, RSA * rsa )
+bool pubkey_rsa_2_bdata( BDATA & pubkey, EVP_PKEY * evp_pkey )
 {
+	const RSA * rsa = EVP_PKEY_get0_RSA(evp_pkey);
+	if (!rsa)
+		return false;
+
 	int size = i2d_RSAPublicKey( rsa, NULL );
 	pubkey.size( size );
 
@@ -664,14 +672,14 @@ static int verify_cb( int ok, X509_STORE_CTX * store_ctx )
 		long ll = LLOG_ERROR;
 		char name[ 512 ];
 
-		X509_NAME * x509_name = X509_get_subject_name( store_ctx->current_cert );
+		X509_NAME * x509_name = X509_get_subject_name( X509_STORE_CTX_get_current_cert( store_ctx ) );
 
 		X509_NAME_oneline(
 			x509_name,
 			name,
 			512 );
 
-		switch( store_ctx->error )
+		switch( X509_STORE_CTX_get_error( store_ctx ) )
 		{
 			case X509_V_ERR_UNABLE_TO_GET_CRL:
 				ok = 1;
@@ -683,9 +691,9 @@ static int verify_cb( int ok, X509_STORE_CTX * store_ctx )
 			ll,
 			"ii : %s(%d) at depth:%d\n"
 			"ii : subject :%s\n",
-			X509_verify_cert_error_string( store_ctx->error ),
-			store_ctx->error,
-			store_ctx->error_depth,
+			X509_verify_cert_error_string( X509_STORE_CTX_get_error( store_ctx ) ),
+			X509_STORE_CTX_get_error( store_ctx ),
+			X509_STORE_CTX_get_error_depth( store_ctx ),
 			name );
 	}
 
@@ -857,7 +865,7 @@ bool prvkey_rsa_load_pem( BDATA & prvkey, FILE * fp, BDATA & pass )
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -883,7 +891,7 @@ bool prvkey_rsa_load_p12( BDATA & prvkey, FILE * fp, BDATA & pass )
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -939,7 +947,7 @@ bool prvkey_rsa_load_pem( BDATA & prvkey, BDATA & input, BDATA & pass )
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -976,7 +984,7 @@ bool prvkey_rsa_load_p12( BDATA & prvkey, BDATA & input, BDATA & pass )
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -1010,7 +1018,7 @@ bool _IKED::pubkey_rsa_read( BDATA & cert, BDATA & pubkey )
 	if( evp_pkey == NULL )
 		return false;
 
-	bool result = pubkey_rsa_2_bdata( pubkey, evp_pkey->pkey.rsa );
+	bool result = pubkey_rsa_2_bdata( pubkey, evp_pkey );
 
 	EVP_PKEY_free( evp_pkey );
 
diff --git a/source/libike/manager.file.cpp b/source/libike/manager.file.cpp
index 67a50ad..7fd3dc3 100644
--- a/source/libike/manager.file.cpp
+++ b/source/libike/manager.file.cpp
@@ -39,6 +39,8 @@
  *
  */
 
+#include <memory>
+
 #include "config.h"
 #include "openssl/rand.h"
 #include "openssl/hmac.h"
@@ -679,11 +681,13 @@ bool _CONFIG_MANAGER::file_pcf_load( CONFIG & config, const char * path, bool &
 			BDATA pwd;
 			data.get( pwd );
 
-			EVP_CIPHER_CTX ctx_cipher;
-			EVP_CIPHER_CTX_init( &ctx_cipher );
+			std::unique_ptr<EVP_CIPHER_CTX, decltype(&EVP_CIPHER_CTX_free)> ctx_cipher {EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_free};
+			if (!ctx_cipher)
+				return false;
+			EVP_CIPHER_CTX_init( ctx_cipher.get() );
 
 			EVP_CipherInit_ex(
-				&ctx_cipher,
+				ctx_cipher.get(),
 				EVP_des_ede3_cbc(),
 				NULL,
 				key,
@@ -691,7 +695,7 @@ bool _CONFIG_MANAGER::file_pcf_load( CONFIG & config, const char * path, bool &
 				0 );
 
 			EVP_Cipher(
-				&ctx_cipher,
+				ctx_cipher.get(),
 				pwd.buff(),
 				pwd.buff(),
 				( unsigned int ) pwd.size() );
